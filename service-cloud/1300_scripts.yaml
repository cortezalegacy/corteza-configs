namespace: service-cloud
scripts:
  CaseInsertCaseNumber:
    source: |-
      let d = new Date();
      let y = d.getFullYear();
      let m = d.getMonth() + 1
      if (m < 10) {
        m = '0' + m
      }
      let day = d.getDate()
      if (day < 10) {
        day = '0' + day
      }
      let h = d.getHours()
      if (h < 10) {
        h = '0' + h
      }
      let min = d.getMinutes()
      if (min < 10) {
        min = '0' + min
      }
      let sec = d.getSeconds()
      if (sec < 10) {
        sec = '0' + sec
      }
      let mil = d.getMilliseconds()
      if (mil < 10) {
        mil = '00' + mil
      } else if (mil < 100) {
        mil = '0' + mil
      }

      let caseNumber = 'Ticket#' + y + m + day + h + min + sec + mil

      $record.values.Number = caseNumber
    async: false
    runInUA: false
    critical: true
    enabled: true
    timeout: 0
    triggers:
    - event: beforeCreate
      module: Case
      resource: compose:record
    - enabled: false
      event: beforeUpdate
      module: Case
      resource: compose:record
  CaseStatusChange:
    source: |-
      // Get the current status of the case
      let currentStatus = $record.values.Status
      let previousStatus = $record.values.PreviousStatus

      // Check if there is no status. If so, the case is new and set it as new.
      if (!currentStatus) {
        currentStatus = 'New'
      }
      if (!previousStatus) {
        previousStatus = 'None'
      }

      // Check if we need to insert a status change update
      if (currentStatus != previousStatus) {
        
        // Insert the status update
        // First, get the default settings
        return Compose.findLastRecord('Settings').then(settings => {
          
          let defaultTimeSpend = settings.values.DefaultTimeUpdate
          let defaultCost = settings.values.DefaultCostPerHour
          let defaultDepartment = settings.values.DefaultDepartment

          // Get the record from the department
          return Compose.findRecordByID(defaultDepartment, 'Department').then(departmentRecord => {

            // Get the cost associated to the department
            if (departmentRecord.values.HourCost) {
              defaultCost = departmentRecord.values.HourCost
            }
            return departmentRecord
            
          }).then(departmentRecord => {
            
            // calculat the total cost
            let totalCost = parseFloat(defaultCost) * parseFloat(defaultTimeSpend)
            
            // Make the update record
            return Compose.makeRecord({
              'CaseId': $record.recordID,
              'Type': 'Status change',
              'Subject': 'Status changed from ' + previousStatus + ' to ' + currentStatus,
              'AccountId': $record.values.AccountId,
              'From': 'Automatic message',
              'Department': defaultDepartment,
              'TimeSpend': defaultTimeSpend,
              'Cost': totalCost
            }, 'Update')
        
              .then(myUpdate => {
        
                return Compose.saveRecord(myUpdate)
        
              }).catch(err => {
                // solve the problem
                console.error(err)
              })
            
          }).then(departmentRecord => {

            // Calculate and store the total price of the ticket
            let totalCost = $record.values.TotalCost
            if (!totalCost || totalCost === '' || isNaN(totalCost)) {
              totalCost = 0
            }
            
            let totalTime = $record.values.TotalTime
            if (!totalTime || totalTime === '' || isNaN(totalTime)) {
              totalTime = 0
            }
            
            // Update the total time and cost in the ticket
            $record.values.TotalCost = parseFloat(totalCost) + (parseFloat(defaultCost) * parseFloat(defaultTimeSpend))
            $record.values.TotalTime = parseFloat(totalTime) + parseFloat(defaultTimeSpend)
            
            // Store the new state in the previous state field
            $record.values.PreviousStatus = currentStatus
            
            return
          
          }).catch(err => {
            // solve the problem
            console.error(err)
          })
          
        }).catch(err => {
          // solve the problem
          console.error(err)
        })

      }
    async: false
    runInUA: false
    critical: true
    enabled: true
    timeout: 0
    triggers:
    - event: beforeUpdate
      module: Case
      resource: compose:record
    - event: beforeCreate
      module: Case
      resource: compose:record
  ContactSetRecordLabel:
    source: |-
      // Set the record label string
      let recordLabel = ''

      // Get the first name
      let firstName = $record.values.FirstName
      if (!firstName) {
        firstName = ''
      }

      // Get the last name
      let lastName = $record.values.LastName
      if (!lastName) {
        lastName = ''
      }

      // Create the full name
      let fullName = ''
      if ((firstName !== '') && (lastName === '')) {
        recordLabel = firstName
      }

      if ((firstName === '') && (lastName !== '')) {
        recordLabel = lastName
      }

      if ((firstName !== '') && (lastName !== '')) {
        recordLabel = firstName + ' ' + lastName
      }

      // Get the company name from the account
      // Check if there is a related account, to map the fields of the account
      let accountId = $record.values.AccountId
      if (accountId) {
          return Compose.findRecordByID(accountId, 'Account').then(accountRecord => {
          
            // Add to the record label 
            recordLabel = recordLabel + ' (' + accountRecord.values.AccountName + ')'
            $record.values.RecordLabel = recordLabel

          }).catch(err => {
            // solve the problem
            $record.values.RecordLabel = recordLabel

            console.error(err)
          })
        
      }
    async: false
    runInUA: false
    critical: true
    enabled: true
    timeout: 0
    triggers:
    - event: beforeCreate
      module: Contact
      resource: compose:record
    - event: beforeUpdate
      module: Contact
      resource: compose:record
  EmailSend:
    source: |-
      const { toJSON, ...values } = $record.values
      $record = new Record($record.module, { ...$record, values })

      Compose.findRecordByID($record.values.ContactId, 'Contact').then(contactRecord => {
        
        return Compose.sendMail(contactRecord.values.Email, $record.values.Subject, { html: $record.values.HtmlBody }).then(() => {
        
          ComposeUI.success(`The email "${$record.values.Subject}" has been sent to "${contactRecord.values.RecordLabel}: ${contactRecord.values.Email}".`)
        
          $record.values.Status = "Sent"
          $record.values.ToAddress = contactRecord.values.Email
          
          var m = new Date()
          var dateString = m.getUTCFullYear() +"/"+ (m.getUTCMonth()+1) +"/"+ m.getUTCDate() + " " + m.getUTCHours() + ":" + m.getUTCMinutes() + ":" + m.getUTCSeconds()
          $record.values.MessageDate = dateString
          Compose.saveRecord($record).then(mySavedRecord => {
            ComposeUI.gotoRecordViewer(mySavedRecord)
            return
          }).catch(err => {
            // solve the problem
            console.error(err)
          })
          
        }).catch(err => {
          // solve the problem
          console.error(err)
        })
        
      }).catch(err => {
        // solve the problem
        console.error(err)
      })
    async: false
    runInUA: true
    critical: true
    enabled: true
    timeout: 0
    triggers:
    - event: manual
      module: EmailMessage
      resource: compose:record
  EmailTemplateLoad:
    source: |-
      const { toJSON, ...values } = $record.values
      $record = new Record($record.module, { ...$record, values })

      if(!$record.recordID) {
        ComposeUI.success(`Please save the record before loading the template`)
        return
      }

      // Check if there is a template
      let templateId = $record.values.EmailTemplateId

      if (templateId) {
        
          // Get the template
          Compose.findRecordByID(templateId, 'EmailTemplate').then(templateRecord => {
        
            // Find the contact    
            Compose.findRecordByID($record.values.ContactId, 'Contact').then(contactRecord => {
              
              // Get all the possible placeholders for the contact
              let replacements = {}
              for (const [key, value] of Object.entries(contactRecord.values)) {
                replacements['{{Contact.' + key + '}}'] = value
              }
        
              // Replace the placeholders for the values
              let body = templateRecord.values.Body
              body = body.replace(/{{\w+}}/g, function(all) {
                return replacements[all] || all
              })
              
              // Fill in the data of the template
              $record.values.Subject = templateRecord.values.Subject
              $record.values.HtmlBody = body
              
              //Save the changes
              return Compose.saveRecord($record)
                .then(mySavedRecord => {
          
                  ComposeUI.success(`The template has been loaded in to the email.`)
                  ComposeUI.gotoRecordEditor(mySavedRecord)
          
                }).catch(err => {
                  // solve the problem
                  ComposeUI.warning(`The template could not be loaded.`)
                  console.error(err)
                })
              
            }).catch(err => {
              // solve the problem
              console.error(err)
            })


        }).catch(err => {
          // solve the problem
          console.error(err)
        })

      }
    async: false
    runInUA: true
    critical: true
    enabled: true
    timeout: 0
    triggers:
    - event: manual
      module: EmailMessage
      resource: compose:record
  KnowledgeBaseInsertKBNumber:
    source: |-
      //Get the default settings
      return Compose.findLastRecord('Settings').then(settings => {
        
        // Map the case number
        let KBNextNumber = settings.values.KBNextNumber
        if (typeof KBNextNumber == "undefined" || KBNextNumber === '' || isNaN(KBNextNumber)) {
          KBNextNumber = 0
        }
        console.log(KBNextNumber)
        $record.values.Number = KBNextNumber
        let KBNextNumberUpdated = parseInt(KBNextNumber,10) + 1
          
        // Update the config
        settings.values.KBNextNumber = KBNextNumberUpdated
        return Compose.saveRecord(settings).then(mySavedSettings => {
          
          console.log('Record saved, new ID', mySavedSettings.recordID)

        }).catch(err => {
        // solve the problem
        console.error(err)
        })
      }).catch(err => {
      // solve the problem
      console.error(err)
      })
    async: false
    runInUA: false
    critical: true
    enabled: true
    timeout: 0
    triggers:
    - enabled: false
      event: beforeUpdate
      module: KnowledgeBase
      resource: compose:record
    - event: beforeCreate
      module: KnowledgeBase
      resource: compose:record
  UpdateAddToCase:
    source: |-
      const { toJSON, ...values } = $record.values
      $record = new Record($record.module, { ...$record, values })

      //Get the default settings
      return Compose.findLastRecord('Settings').then(settings => {

        let department = settings.values.DefaultDepartment
        let timeSpend = settings.values.DefaultTimeUpdate
        let defaultCostPerHour = settings.values.DefaultCostPerHour
        let updateCost = 0
        if (timeSpend) {
          updateCost = parseFloat(defaultCostPerHour) * parseFloat(timeSpend)
        }

        // Create the related update
        return Compose.makeRecord({
          'CaseId': $record.recordID,
          'AccountId': $record.values.AccountId,
          'ContactId': $record.values.ContactId,
          'Department': settings.values.DefaultDepartment,
          'Cost': updateCost,
          'TimeSpend': timeSpend
        }, 'Update')

          .then(myUpdate => {

            return Compose.saveRecord(myUpdate)

          }).then(mySavedUpdate => {

            ComposeUI.gotoRecordEditor(mySavedUpdate)

          }).catch(err => {
            // solve the problem
            console.error(err)
          })

      }).catch(err => {
        // solve the problem
        console.error(err)
      })
    async: false
    runInUA: true
    critical: true
    enabled: true
    timeout: 0
    triggers:
    - enabled: false
      event: manual
      module: Update
      resource: compose:record
    - event: manual
      module: Case
      resource: compose:record
  UpdateSendEmail:
    source: |-
      const { toJSON, ...values } = $record.values
      $record = new Record($record.module, { ...$record, values })

      // Get the default template from the settings.
      return Compose.findLastRecord('Settings').then(settings => {
        let templateId = settings.values.DefaultCaseEmailTemplate

        if (templateId) {

          // Get the placeholder for the Case
          let replacements = {}
          for (const [key, value] of Object.entries($record.values)) {
            replacements['{{Case.' + key + '}}'] = value
          }

          // Get the placeholder for the Contact
          Compose.findRecordByID($record.values.ContactId, 'Contact').then(contactRecord => {

            // Get all the possible Contact placeholders
            for (const [key, value] of Object.entries(contactRecord.values)) {
              replacements['{{Contact.' + key + '}}'] = value
            }

            // Get the default template
            return Compose.findRecordByID(templateId, 'EmailTemplate').then(templateRecord => {

              // Replace the placeholders for the values in the subject
              let subject = templateRecord.values.Subject
              subject = subject.replace(/{{\w+}}/g, function (all) {
                return replacements[all] || all
              })

              // Replace the placeholders for the values in the body
              let body = templateRecord.values.Body
              body = body.replace(/{{\w+}}/g, function (all) {
                return replacements[all] || all
              })
              
              // Create the email
              return Compose.makeRecord({
                'HtmlBody': body,
                'Subject': subject,
                'Status': 'Draft',
                'EmailTemplateId': templateId,
                'CaseId': $record.recordID,
                'ContactId': $record.values.ContactId
              }, 'EmailMessage')
                .then(myEmailMessage => {

                  return Compose.saveRecord(myEmailMessage)

                }).then(mySavedEmailMessage => {

                  // Redirect to the email record
                  ComposeUI.gotoRecordEditor(mySavedEmailMessage)

                }).catch(err => {
                  // solve the problem
                  console.error(err)
                })

            }).catch(err => {
              // solve the problem
              console.error(err)
            })
          }).catch(err => {
            // solve the problem
            console.error(err)
          })
        }
      }).catch(err => {
        // solve the problem
        console.error(err)
      })
    async: false
    runInUA: true
    critical: true
    enabled: true
    timeout: 0
    triggers:
    - event: manual
      module: Case
      resource: compose:record
  UpdateSendNotificationsAndCalculateTimeAndCost:
    source: |-
      // Check if the type is NOT an incoming email. If it's not, handle it as an internal update and send notifications
      if ($record.values.Type !== 'Incoming email') {

        //Get the cost related to the department that updated the case
        return Compose.findRecordByID($record.values.Department, 'Department').then(departmentRecord => {
          let hourCost = 0
          if (departmentRecord.values.HourCost) {
            hourCost = parseFloat(departmentRecord.values.HourCost)
          }
          return hourCost
        }).catch(err => {
          // solve the problem
          let hourCost = 0
          return hourCost
        })

          .then((hourCost) => {
            // Calculate the cost of the update
            let updateTime = $record.values.TimeSpend
            let UpdateCost = 0
            if (updateTime) {
              UpdateCost = parseFloat(hourCost) * parseFloat(updateTime)
            }

            // Add the cost to the update
            $record.values.Cost = UpdateCost

            // Set the notifications values to "1" (sent)
            if ($record.values.SendToMailingList) {
              $record.values.NotificationCaseMailingList = 1
            }
            $record.values.NotificationCaseCreator = 1

            // Find the case related to the update
            // Add the total cost and get the content for the email and message notifications
            Compose.findRecordByID($record.values.CaseId, 'Case').then(caseRecord => {

              // Get the current time and cost of the case
              let caseTime = caseRecord.values.TotalTime
              if (typeof caseTime == "undefined" || caseTime === '' || isNaN(caseTime)) {
                caseTime = 0
              }
              let caseCost = caseRecord.values.TotalCost
              if (typeof caseCost == "undefined" || caseCost === '' || isNaN(caseCost)) {
                caseCost = 0
              }

              caseTime = parseFloat(caseTime) + parseFloat(updateTime)
              caseCost = parseFloat(caseCost) + parseFloat(UpdateCost)

              // Save the values in the case
              caseRecord.values.TotalTime = caseTime
              caseRecord.values.TotalCost = caseCost

              return Compose.saveRecord(caseRecord).then(mySavedCase => {
                console.log('Record saved, ID', mySavedCase.recordID)
              }).then(() => {

                // Create the update text to send out via email
                let html = 'Hi,'
                html += '<br>'
                html += '<br>'
                html += 'The following case has been updated:'
                html += '<br>'
                html += '<ul>'
                html += '<li><strong>Case ID:</strong> ' + caseRecord.values.Number + '</li>'
                html += '<li><strong>Subject:</strong> ' + caseRecord.values.Subject + '</li>'
                html += '<li><strong>Type:</strong> ' + caseRecord.values.Category + '</li>'
                html += '<li><strong>Status:</strong> ' + caseRecord.values.Status + '</li>'
                html += '<li><strong>Priority:</strong> ' + caseRecord.values.Priority + '</li>'
                html += '</ul>'
                html += '<br>'
                html += 'Update:'
                html += '<br>'
                html += '<ul>'
                html += '<li><strong>Type:</strong> ' + $record.values.Type + '</li>'
                html += '<li><strong>Subject:</strong> ' + $record.values.Subject + '</li>'
                html += '<li><strong>Content:</strong> ' + $record.values.Content + '</li>'
                html += '</ul>'
                html += '<br>'
                html += 'Kind regards,'
                html += '<br>'
                html += '<br>'
                html += 'Service Cloud'
                html += '<br>'
                html += '<br>'
                html += '--'
                html += '<br>'
                html += 'Ticket Summary:'
                html += '<hr>'
                html += caseRecord.values.Description


                return Compose.findLastRecord('Settings').then(settings => {
                  let defaultChannel = settings.values.DefaultSupportChannel
                  let defaultCaseRecordLink = settings.values.DefaultCaseRecordLink

                  // Get default settings to find if there is a channel to inform        
                  if (defaultChannel && defaultCaseRecordLink) {
                    return Messaging.sendMessage('Automatic update. "' + caseRecord.values.Number + '" has been updated: ' + $record.values.Subject + ' (type: ' + $record.values.Type + '). Direct link: ' + defaultCaseRecordLink + $record.recordID, defaultChannel)
                  }
                }).then(() => {
                  // Get the contact of the case record to infor via email
                  if (caseRecord.values.ContactId) {
                    Compose.findRecordByID(caseRecord.values.ContactId, 'Contact').then(contactRecord => {

                      // Check if the contact has an email address
                      if (contactRecord.values.Email) {

                        // Send the update text
                        return Compose.sendMail(contactRecord.values.Email, '[' + caseRecord.values.Number + '] Update: ' + caseRecord.values.Subject, { html: html })
                      }
                    }).catch(err => {
                      // solve the problem
                      console.error(err)
                    })
                  }

                }).catch(err => {
                  // solve the problem
                  console.error(err)
                })

              }).catch(err => {
                // solve the problem
                console.error(err)
              })
            }).catch(err => {
              // solve the problem
              console.error(err)
            })
          }).catch(err => {
            // solve the problem
            console.error(err)
          })
      }
    async: false
    runInUA: false
    critical: true
    enabled: true
    timeout: 0
    triggers:
      event: beforeUpdate
      module: Update
      resource: compose:record
